Numpy
    리스트의 한계점 - 데이터 분석에서는 수학적 계산이 가능해야 하며 / 대랑의 데이터를 처리하는데 속도가 빨라야 함
    수치 연산을 위해 배열(Array)을 생성하고 다루는 패키지
        Array의 구조 - Axis, Rank, Shape
        Array 조회 - 인덱스 : 특정 인덱스, 여러 인덱스, 범위 / 조건 조회
        reshape로 변형 / 연산 / 집계

    사용하려면 라이브러리를 먼저 불러와야 한다 >> import numpy >> 인데 보통 import numpy as np 로 별명을 붙이는게 국룰이다.
        1~3차원의 배열을 만들 수 있다 / reshape로 배열 형태를 바꿀 수 있다 / 인덱싱, 슬라이싱으로 데이터를 조회할 수 있다 / 기본적 연산

    배열 만들기
        용어
            axis - 배열의 축
            rank - 축의 개수. 즉 차원
            shape - 축의 길이, 배열의 크기
                ex) 3x4 배열은? - axis0, axis1을 갖는 2차원 배열 / rank2 array(2차원 배열) / shape - (3,4) 

        만들기
            np.array() 함수로 지정
                1차원 배열은 [] 대괄호가 1개
                    ex) a1 = np.array([6,7,8,9,10])
                        [6,7,8,9,10]으로 구성된 1차원 배열이 나온다.

                2차원 배열은 [[]] 대괄호가 2개
                    ex) a2 = np.array([[1, 2, 3], [4, 5, 6]])
                        [[1,2,3]
                         [4,5,6]] 으로 구성된 2차원 배열이 나온다.
                         
                3차원 배열은 [[[]]] 대괄호가 3개
                    ex) a3 = np.array([[[1, 3, 1], [4, 7, 6], [8, 3, 4]], [[6, 2, 4], [8, 1, 5], [3, 5, 9]]])
                        [[[1 3 1]
                          [4 7 6]
                          [8 3 4]]
                         [[6 2 4]
                          [8 1 5]
                          [3 5 9]]] 으로 구성된 3차원 배열이 나온다.
        
    배열 정보 확인
        차원 확인 - ndim 으로 확인
            ex) print(a3.ndim) - 하면 3이 출력된다(a3은 위에서 만든거). - 3차원
        형태(크기) 확인 - shape 으로 확인
            ex) print(a3.shape) - 하면 (2,3,3)이 출력된다.
        요소 자료형 확인 - dtype 으로 확인 - 배열은 한가지 자료형만 가질 수 있다
            ex) print(a3.dtype) - 하면 int32 가 출력된다. - 근데 저 32는 뭐지?
    
    Reshape
        배열은 사용하면서 형태를 변환하는것 - 배열에 포함된 요소가 사라지지 않아야 하며, 개수가 변하지 말아야 함
            ex) (3, 4) → (2, 6) → (4, 3) → (12, 1) → (6, 2) - 이 경우는 12의 약수로 구성해야 한다는 뜻
            ex) (2,3) 형태의 배열 만들어서 (3,2)로 바꿔보기
                a23 = np.array([[1, 2, 3],[4, 5, 6]])
                [[1 2 3]
                 [4 5 6]] 이 만들어진다.
                a32 = a23.reshape(3,2)
                [[1 2]
                 [3 4]
                 [5 6]] 의 형태로 변환된다.
        -1의 편리성 - 행과 열 중 어느 한쪽을 -1로 설정하면 다른 한 쪽은 자동으로 알맞은 숫자로 바뀐다.
    
    배열 인덱싱과 슬라이싱
        인덱싱 - 인덱스니까 당연하게도 1행, 1열의 인덱스 넘버는 1이 아닌 0부터 시작한다!
            array[행,열] 형태로 특정 위치의 요소를 조회
            array[[행1,행2, ...], :] 또는 array[[행1,행2, ...]] 형태로 특정 행을 조회 - :은 앞뒤로 별다른 입력이 없다면 전체가 된다
            array[:, [열1,열2,...]] 형태로 특정 열을 조회 - 이건 왜 행과 다르게 : 생략 형태가 없을까? - 행이 먼저 오기 때문에?
            array[[행1,행2,...], [열1,열2,...]] 형태로 특정 행의 특정 열을 조회
                ex)
                [[1 2 3]
                 [4 5 6]
                 [7 8 9]] 형태의 array가 있다면
                a[0,1] 은 첫째행의 둘째열의 요소를 조회한다 - 즉 2
                a[[0,1]] / a[[0,1] :] 은 첫째와 둘째행의 요소를 조회한다 - 즉 123 456
                a[:, [0,1]] 은 첫째와 둘째열의 요소를 조회한다 - 즉 12 45 78
                a[[1],[1]] 은 둘째열의 둘째행의 요소를 조회한다 - 즉 5

        슬라이싱
            array[행1:행N,열1:열N] 형태로 지정해 그 위치의 요소를 조회 - 결화는 2차원 배열이 되며, 마지막 범위 값은 대상에 미포함
                ex)
                [[1 2 3]
                 [4 5 6]
                 [7 8 9]] 형태의 array가 있다면
                a([0:2, :]) / a([0:2]) 은 첫번쨰~두번째 행을 조회한다 - 즉 123 456
                    인덱스 0은 첫번째 행이고 2는 3번째 행이지만, 마지막 범위 값, 즉 인덱스 2는 포함되지 않으므로 그 앞인 2번째 행까지 조회
                a([0, 0:2]) 은 첫번째 행, 첫번째~두번째 열을 조회한다 - 즉 12
                a([0:3, 1:3]) 은 첫번째~세번째 행, 두번째~세번째 열을 조회한다 - 즉 23 56 89
                a([1:,1:]) 은 두번째~마지막 행, 두번째~마지막 열을 조회한다 - 즉 56 89

        조건 조회
            조건에 맞는 요소를 선택하는 방식 - boolean 방식이라고도 부름 - 조회 결과는 1차원 배열이 됨
            array[조건] 형태로 해당 조건에 맞는 요소만 조회 - 검색 조건을 변수로 선언해 사용할 수도 있다 - &와 |로 연결하여 조회 가능
                ex) score = [[78 91 84 89 93 65]
                             [82 87 96 79 91 73]]
                    score[score >= 90] 은 90 이상인 요소만 조회 - condition = score >= 90 으로 지정하고 score[condition] 도 가능
                    score[(score >= 90) & (score <= 95)] 은 90이상 95이하인 요소만 조회
        
    배열 연산
        배열 사칙연산
            더하기 - + 또는 np.add() / 빼기 - - 또는 np.substract()
            곱하기 - * 또는 np.multiply / 나누기 - / 또는 np.divide()
            지수 연산 - ** 또는 np.power()
                ex)x               y
                [[1, 2]         [[5, 6]
                 [3, 4]]         [7, 8]]
                x+y / np.add(x,y)   [[6  8 ]
                                     [10 12]]
                x-y / np.substract(x,y) [[-4 -4]
                                         [-4 -4]]
                x*y / np.multiply(x,y) [[ 5 12]
                                        [21 32]]
                x/y / np.divide(x,y) [[0.2        0.33333333]
                                      [0.42857143 0.5       ]]
                x**y / np.power(x,y) [[    1    64]
                                      [ 2187 65536]]
                x**2 [[ 1  4]
                      [ 9 16]]
        
        배열 집계
            np.sum(), array.sum() / 동일한 형태로 np.max(), np.min(), np.mean(), np.std() (표준편차) 사용 가능
            axis = 0 - 열 기준 집계 / axis = 1 - 행 기준 집계 / 생략하면 전체 집계
                ex) a
                [[1 5 7]
                 [2 3 8]]
                np.sum(a) - 26 - 전체 집계
                np.sum(a, axis = 0) - [3 8 15] - [1+2 5+3 7+8]
                np.sum(a, axis = 1) - [13 13] - [1+5+7 2+3+8]

        자주 사용되는 함수들
            np.argmax() - 전체 배열에서 최댓값의 인덱스, np.argmin() - 전체 배열에서 최솟값의 인덱스
            np.argmax(a, axis = 0) - 행 방향으로 최댓값의 인덱스
            np.argmax(a, axis = 1) - 열 방향으로 최댓값의 인덱스
                ex) a
                [[1 5 7]
                 [2 3 8]]
                np.argmax() - 5 - 가장 큰 요소인 8의 인덱스
                np.argmax(a, axis = 0) - [1 0 1] - 1행의 1과 2 중 큰값은 2의 인덱스넘버 1, 같은 방식으로 0과 1
                np.argmax(a, axis = 1) - [2 2] - 1열에서 최댓값인 7의 인덱스넘버 2, 같은 방식으로 2
            np.where(조건문, True일 때 값, False일 때 값)
                ex) a
                [1 3 2 7]
                np.where(a>2,1,0) - array([0,1,0,1]) - 조건인 2보다 큰가? 에 대해 순서대로 F T F T 이므로.
